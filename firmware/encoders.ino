#include <Encoder.h>

// Pin change interrupt history
volatile uint8_t portBHistory = 0;

// Encoder constants
const int ENCODER_NUM_LINES = 16;
const int ENCODER_NUM_PULSES = ENCODER_NUM_LINES*2;

// Encoders data
Encoder motorA(ENC_A_CH_A, ENC_A_CH_B);
Encoder motorB(ENC_B_CH_A, ENC_B_CH_B);

// Encoder pulses tracking
long encoderPulsesA = 0;
long encoderPulsesB = 0;

/**
 * Set interrupt routines for ATMega 32U4.
 * References: https://www.arduino.cc/en/Reference/AttachInterrupt
 */
void setEncoderInterrupts() {
  attachInterruptA();
  attachInterruptB();
}

/**
 * Attach interrupt routine to encoder A.
 */
void attachInterruptA() {
  // We want to enable interrupts in SparkFun Pro Micro's pin 8.
  // Searching through its datasheet, we see that it pin 8 corresponds
  // to the ATMega32U4 PB4(ADC11) input.
  //
  // Finally, pages 87 and 88 of the ATMega32U4 datasheet shows that PCICR
  // and PCMSK0 are the registers we need to know about.
  //
  // In order to enable pin change interrupts, bit 0 in PCICR register
  // must be enabled, as well as the interrupt correspondent bit in
  // register PCMSK0. For instance, PCINT4 requires bit 4 to be set.
  //
  // Also, bit 0 in PCMSK0 (corresponding to PCINT0) must be enabled so
  // as the controller can process pin change interrupts.
  //
  // References:
  // https://sites.google.com/site/qeewiki/books/avr-guide/external-interrupts-on-the-atmega328
  // http://rcarduino.blogspot.com.br/2013/04/the-problem-and-solutions-with-arduino.html
  // http://www.geertlangereis.nl/Electronics/Pin_Change_Interrupts/PinChange_en.html
  
  cli();
  PCICR |= (1 << PCIE0);
  PCMSK0 |= 1 | (1 << PCINT4);
  sei();
}

/**
 * Process pin change interrupts.
 */
#if defined(PCINT0_vect)
ISR(PCINT0_vect) {
  uint8_t changedBits;

  // Compares pin change interrupts current state with the previous state
  changedBits = PINB ^ portBHistory;
  portBHistory = PINB;

  // Calls interrupt routine with pin change interrupt 4
  if (changedBits & (1 << PCINT4))
    doEncoderA();

  // Required by UnBallSoftwareSerial
  UnBallSoftwareSerial::handle_interrupt();
}
#endif

/**
 * Attach interrupt routine to encoder B.
 */
void attachInterruptB() {
  // Interrupt 0 corresponds to ATMega32U4 pin 3.
  // Reference: http://rcarduino.blogspot.com.br/2013/04/the-problem-and-solutions-with-arduino.html
  attachInterrupt(0, doEncoderB, CHANGE);
}

/**
 * Interrupt routine to encoder A. Count the number of pulses generated by
 * encoder A.
 */
void doEncoderA() {
  if (digitalRead(ENC_A_CH_A) == digitalRead(ENC_A_CH_B))
    encoderPulsesA++;
  else
    encoderPulsesA--;
}

/**
 * Interrupt routine to encoder B. Count the number of pulses generated by
 * encoder B.
 */
void doEncoderB() {
  if (digitalRead(ENC_B_CH_A) == digitalRead(ENC_B_CH_B))
    encoderPulsesB++;
  else
    encoderPulsesB--;
}

/**
 * Reset encoder pulses tracking.
 */
void resetEncoders() {
  encoderPulsesA = 0;
  encoderPulsesB = 0;
}

/**
 * Calculate speed based on encode pulses.
 * @param encoderPulses Encoder pulses since last loop.
 * @return Speed in RPM.
 */
float calculateSpeed(long encoderPulsesDiff) {
  float dt = getTimeInterval();
  return (encoderPulsesDiff/(float)ENCODER_NUM_PULSES)*(60.0/dt);
}

/**
 * Calculate motor speeds.
 */
void calculateSpeeds() {
  speedA = calculateSpeed(encoderPulsesA);
  speedB = calculateSpeed(encoderPulsesB);
}

/**
 * Print encoders data.
 */
void printEncoders() {
  Serial.print("  pulses A: ");
  Serial.print(encoderPulsesA);
  Serial.print("  pulses B: ");
  Serial.println(encoderPulsesB);
}

/**
 * Print motors speed.
 */
void printSpeeds() {
  Serial.print("  speed A: ");
  Serial.print(speedA);
  Serial.print("  speed B: ");
  Serial.println(speedB);
}
